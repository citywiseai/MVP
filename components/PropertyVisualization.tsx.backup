"use client";

import React, { useEffect, useRef, useState, useCallback } from 'react';
import { toast } from 'sonner';
import L from 'leaflet';
import 'leaflet/dist/leaflet.css';
import 'leaflet-draw';
import 'leaflet-draw/dist/leaflet.draw.css';
import * as turf from '@turf/turf';
import { Card } from '@/components/ui/card';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { Label } from '@/components/ui/label';
import { Loader2, Maximize2, Minimize2, Map, Building2, Grid3x3, MapPin, Save, Edit, X, AlertTriangle, Check, Tag, Trash2, Pencil, Move, HelpCircle } from 'lucide-react';
import MapToolbar from './MapToolbar';
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogHeader,
  DialogTitle,
  DialogTrigger,
} from '@/components/ui/dialog';

interface PropertyVisualizationProps {
  projectId: string;
  parcelData?: any;
  buildingFootprint?: any;
}

interface EdgeLabel {
  edgeIndex: number;
  side: 'front' | 'rear' | 'left' | 'right';
}

interface DrawnShape {
  id: string;
  name: string;
  area: number;
  perimeter: number;
  layer: any;
  dimensionLabels: any[];
}

export default function PropertyVisualization({
  projectId,
  parcelData,
  buildingFootprint
}: PropertyVisualizationProps) {
  const mapContainer = useRef<HTMLDivElement>(null);
  const map = useRef<L.Map | null>(null);
  const editablePolygon = useRef<L.Polygon | null>(null);
  const displayPolygon = useRef<L.Polygon | null>(null);
  const buildingLayer = useRef<L.GeoJSON | null>(null);
  const setbackLayer = useRef<L.LayerGroup | null>(null);
  const drawLayer = useRef<L.FeatureGroup | null>(null);
  const drawControl = useRef<any>(null);
  const editControl = useRef<any>(null);
  const satelliteLayer = useRef<L.TileLayer | null>(null);
  const streetLayer = useRef<L.TileLayer | null>(null);
  const vertexMarkers = useRef<L.Marker[]>([]);
  const edgeMarkers = useRef<L.Marker[]>([]);
  
  const [isLoading, setIsLoading] = useState(true);
  const [isFullscreen, setIsFullscreen] = useState(false);
  const [activeLayer, setActiveLayer] = useState<'satellite' | 'street'>('satellite');
  const [showParcel, setShowParcel] = useState(true);
  const [showSetbacks, setShowSetbacks] = useState(true);
  const [isEditingBoundary, setIsEditingBoundary] = useState(false);
  const [isEditingSetbacks, setIsEditingSetbacks] = useState(false);
  const [isLabelingEdges, setIsLabelingEdges] = useState(false);
  const [isDrawing, setIsDrawing] = useState(false);
  const [isEditingShapes, setIsEditingShapes] = useState(false);
  const [boundaryCoords, setBoundaryCoords] = useState<[number, number][]>([]);
  const [edgeLabels, setEdgeLabels] = useState<EdgeLabel[]>([]);
  const [drawnShapes, setDrawnShapes] = useState<DrawnShape[]>([]);
  const [editingShapeId, setEditingShapeId] = useState<string | null>(null);
  
  const [setbacks, setSetbacks] = useState({
    front: 20,
    rear: 15,
    left: 5,
    right: 5
  });
  
  const [mode, setMode] = useState<'view' | 'edit' | 'measure'>('view');
  const [isDraggingVertex, setIsDraggingVertex] = useState(false);
  const [draggedVertexIndex, setDraggedVertexIndex] = useState<number | null>(null);
  const [isShiftPressed, setIsShiftPressed] = useState(false);
  const [isSpacePressed, setIsSpacePressed] = useState(false);
  const [originalVertexPosition, setOriginalVertexPosition] = useState<L.LatLng | null>(null);

  // Keyboard shortcuts for mode switching
  useEffect(() => {
    const handleKeyDown = (e: KeyboardEvent) => {
      // Don't trigger if user is typing in an input
      if (e.target instanceof HTMLInputElement || e.target instanceof HTMLTextAreaElement) {
        return;
      }

      if (e.key === ' ') {
        e.preventDefault();
        setIsSpacePressed(true);
        if (map.current) {
          map.current.dragging.enable();
          map.current.getContainer().style.cursor = 'grab';
        }
        return;
      }

      if (e.key === 'Shift') setIsShiftPressed(true);
      
      if (e.key === 'Escape' && isDraggingVertex) {
        if (originalVertexPosition && draggedVertexIndex !== null) {
          // Restore marker position
          if (vertexMarkers.current[draggedVertexIndex]) {
            vertexMarkers.current[draggedVertexIndex].setLatLng(originalVertexPosition);
          }
          
          // Restore boundary coords and redraw polygon
          setBoundaryCoords(prevCoords => {
            const newCoords = [...prevCoords];
            newCoords[draggedVertexIndex] = [originalVertexPosition.lat, originalVertexPosition.lng];
            
            // Update editable polygon
            if (editablePolygon.current) {
              editablePolygon.current.setLatLngs(newCoords);
            }
            
            return newCoords;
          });
        }
        setIsDraggingVertex(false);
        setDraggedVertexIndex(null);
        setOriginalVertexPosition(null);
        toast.info('Edit cancelled');
        return;
      }

      switch(e.key.toLowerCase()) {
        case '1':
        case 'v':
          setMode('view');
          break;
        case '2':
        case 'e':
          setMode('edit');
          toast.info('Edit mode active. Hold Space to pan, Shift to snap', { duration: 3000 });
          break;
        case '3':
        case 'm':
          setMode('measure');
          break;
        case 'escape':
          setMode('view');
          break;
      }
    };

    const handleKeyUp = (e: KeyboardEvent) => {
      if (e.key === ' ') {
        setIsSpacePressed(false);
        if (map.current) {
          map.current.getContainer().style.cursor = '';
        }
      }
      if (e.key === 'Shift') setIsShiftPressed(false);
    };

    window.addEventListener('keydown', handleKeyDown);
    window.addEventListener('keyup', handleKeyUp);
    return () => {
      window.removeEventListener('keydown', handleKeyDown);
      window.removeEventListener('keyup', handleKeyUp);
    };
  }, [isDraggingVertex]);
  
  const [buildableArea, setBuildableArea] = useState<number | null>(null);
  const [violations, setViolations] = useState<string[]>([]);

  const snapToGrid = (value: number, gridSize: number = 0.00001) => {
    return Math.round(value / gridSize) * gridSize;
  };

  const vertexIcon = (index: number) => L.divIcon({
    className: 'custom-vertex-marker',
    html: `
      <div class="vertex-wrapper ${draggedVertexIndex === index ? 'dragging' : ''}">
        <div class="vertex-dot"></div>
        <div class="vertex-ring"></div>
        ${isShiftPressed && isDraggingVertex ? '<div class="snap-indicator">SNAP</div>' : ''}
      </div>
    `,
    iconSize: [24, 24],
    iconAnchor: [12, 12]
  });

  const getEdgeIcon = (side: 'front' | 'rear' | 'left' | 'right' | null) => {
    const colors = {
      front: '#ef4444',
      rear: '#3b82f6',
      left: '#10b981',
      right: '#f59e0b'
    };
    
    const labels = {
      front: 'Front',
      rear: 'Rear',
      left: 'Left',
      right: 'Right'
    };
    
    const color = side ? colors[side] : '#9ca3af';
    const label = side ? labels[side] : 'Click';
    
    return L.divIcon({
      className: 'edge-marker',
      html: `<div style="
        background-color: ${color};
        color: white;
        border: 2px solid white;
        border-radius: 6px;
        padding: 4px 8px;
        font-size: 11px;
        font-weight: 600;
        cursor: pointer;
        box-shadow: 0 2px 4px rgba(0,0,0,0.3);
        white-space: nowrap;
      ">${label}</div>`,
      iconSize: [50, 24],
      iconAnchor: [25, 12]
    });
  };

  const createDimensionLabels = (coords: [number, number][]) => {
    const dimensionLabels: any[] = [];

    for (let i = 0; i < coords.length; i++) {
      const nextIndex = (i + 1) % coords.length;
      const coord1 = coords[i];
      const coord2 = coords[nextIndex];

      const point1 = turf.point([coord1[1], coord1[0]]);
      const point2 = turf.point([coord2[1], coord2[0]]);
      const distanceMeters = turf.distance(point1, point2, { units: 'meters' });
      const distanceFeet = Math.round(distanceMeters * 3.28084);

      const midLat = (coord1[0] + coord2[0]) / 2;
      const midLng = (coord1[1] + coord2[1]) / 2;

      const dimensionLabel = L.marker([midLat, midLng], {
        icon: L.divIcon({
          className: 'dimension-label',
          html: `
            <div style="
              background-color: rgba(255, 255, 255, 0.95);
              border: 2px solid #2563eb;
              border-radius: 4px;
              padding: 2px 6px;
              font-size: 11px;
              font-weight: 600;
              color: #2563eb;
              box-shadow: 0 1px 3px rgba(0,0,0,0.3);
              white-space: nowrap;
            ">${distanceFeet}'</div>
          `,
          iconSize: [40, 20],
          iconAnchor: [20, 10]
        })
      });

      dimensionLabels.push(dimensionLabel);
    }

    return dimensionLabels;
  };

  const ensureClosedPolygon = (coords: [number, number][]) => {
    if (coords.length === 0) return coords;
    const first = coords[0];
    const last = coords[coords.length - 1];
    if (first[0] !== last[0] || first[1] !== last[1]) {
      return [...coords, first];
    }
    return coords;
  };

  const checkViolations = useCallback((drawnShape: any) => {
    if (!boundaryCoords || boundaryCoords.length === 0) {
      console.log('No boundary coords for violation check');
      return;
    }

    try {
      const geojson = {
        type: 'Polygon',
        coordinates: [ensureClosedPolygon(boundaryCoords.map(c => [c[1], c[0]]))]
      };

      const parcelPolygon = turf.polygon(geojson.coordinates);
      
      const minSetbackFeet = Math.min(setbacks.front, setbacks.rear, setbacks.left, setbacks.right);
      const minSetbackMeters = minSetbackFeet * 0.3048;
      const setbackPolygon = turf.buffer(parcelPolygon, -minSetbackMeters / 1000, { units: 'kilometers' });

      if (!setbackPolygon) {
        setViolations(['‚ö†Ô∏è Cannot calculate setback area']);
        return;
      }

      const drawnPolygon = turf.polygon(drawnShape.geometry.coordinates);
      const isWithin = turf.booleanWithin(drawnPolygon, setbackPolygon);

      console.log('Violation check:', { isWithin, minSetbackFeet });

      if (!isWithin) {
        setViolations(['‚ùå Building footprint violates setback requirements!']);
      } else {
        setViolations(['‚úÖ Building footprint complies with setbacks']);
      }

    } catch (error) {
      console.error('Error checking violations:', error);
      setViolations(['‚ö†Ô∏è Error checking setback compliance']);
    }
  }, [boundaryCoords, setbacks]);

  useEffect(() => {
    console.log('üöÄ Map useEffect running', { hasContainer: !!mapContainer.current, hasMap: !!map.current, hasParcelData: !!parcelData });
    if (!mapContainer.current || map.current) return;

    let centerLat = 33.4484;
    let centerLng = -111.8910;
    
    if (parcelData?.latitude && parcelData?.longitude) {
      centerLat = parcelData.latitude;
      centerLng = parcelData.longitude;
    }

    map.current = L.map(mapContainer.current, {
      center: [centerLat, centerLng],
      zoom: 19,
      zoomControl: false,
    });

    L.control.zoom({ position: 'topright' }).addTo(map.current);

    satelliteLayer.current = L.tileLayer(
      'https://mt1.google.com/vt/lyrs=s&x={x}&y={y}&z={z}',
      {
        attribution: '¬© Google',
        maxZoom: 22,
        subdomains: ['mt0', 'mt1', 'mt2', 'mt3']
      }
    );

    streetLayer.current = L.tileLayer(
      'https://mt1.google.com/vt/lyrs=m&x={x}&y={y}&z={z}',
      {
        attribution: '¬© Google',
        maxZoom: 22,
        subdomains: ['mt0', 'mt1', 'mt2', 'mt3']
      }
    );

    satelliteLayer.current.addTo(map.current);

    setbackLayer.current = L.layerGroup().addTo(map.current);
    drawLayer.current = L.featureGroup().addTo(map.current);

    drawControl.current = new (L.Control as any).Draw({
      draw: {
        polygon: {
          allowIntersection: false,
          showArea: true,
          shapeOptions: {
            color: '#4A90E2',
            fillColor: '#4A90E2',
            fillOpacity: 0.3
          }
        },
        rectangle: {
          shapeOptions: {
            color: '#4A90E2',
            fillColor: '#4A90E2',
            fillOpacity: 0.3
          }
        },
        circle: false,
        circlemarker: false,
        marker: false,
        polyline: false
      },
      edit: {
        featureGroup: drawLayer.current,
        remove: false
      }
    });

    try {
      editControl.current = new (L.Control as any).Draw({
        draw: false,
        edit: {
          featureGroup: drawLayer.current,
          edit: {
            selectedPathOptions: {
              maintainColor: true,
              opacity: 0.6
            }
          },
          remove: false
        }
      });
    } catch (error) {
      console.error('Error initializing edit control:', error);
    }

    let boundaryCoords = parcelData?.boundaryCoordinates;
    
    if (typeof boundaryCoords === 'string') {
      try {
        boundaryCoords = JSON.parse(boundaryCoords);
      } catch (e) {
        console.error('Failed to parse boundaryCoordinates');
      }
    }

    if (boundaryCoords && Array.isArray(boundaryCoords) && boundaryCoords.length > 0) {
      const coords = boundaryCoords.map((coord: number[]) => [coord[1], coord[0]] as [number, number]);
      const coordsWithoutDupe = coords.slice(0, -1);
      setBoundaryCoords(coordsWithoutDupe);
      addParcelLayer(coordsWithoutDupe);
      
      if (parcelData?.edgeLabels) {
        setEdgeLabels(parcelData.edgeLabels);
      }
      
      const closedGeometry = {
        type: 'Polygon',
        coordinates: [ensureClosedPolygon(coordsWithoutDupe.map(c => [c[1], c[0]]))]
      };
      calculateAndDrawSetbacks(closedGeometry);
    }

    if (buildingFootprint) {
      addBuildingLayer(buildingFootprint);
    }

    setIsLoading(false);

    return () => {
      map.current?.remove();
      map.current = null;
    };
  }, [parcelData, buildingFootprint]);

  useEffect(() => {
    if (!map.current || !satelliteLayer.current || !streetLayer.current) return;

    if (activeLayer === 'satellite') {
      map.current.removeLayer(streetLayer.current);
      map.current.addLayer(satelliteLayer.current);
    } else {
      map.current.removeLayer(satelliteLayer.current);
      map.current.addLayer(streetLayer.current);
    }
  }, [activeLayer]);

  const addParcelLayer = (coords: [number, number][]) => {
    console.log('üó∫Ô∏è addParcelLayer called with', coords.length, 'coords');
    if (!map.current) {
      console.log('‚ùå No map');
      return;
    }

    // Validate coordinates
    if (!coords || coords.length < 3) {
      console.error('Invalid coordinates for parcel layer:', coords);
      return;
    }

    // Check for invalid lat/lng values
    const validCoords = coords.filter(coord => {
      const [lat, lng] = coord;
      return !isNaN(lat) && !isNaN(lng) &&
             lat >= -90 && lat <= 90 &&
             lng >= -180 && lng <= 180;
    });

    if (validCoords.length < 3) {
      console.error('Not enough valid coordinates:', validCoords);
      return;
    }

    if (displayPolygon.current) {
      map.current.removeLayer(displayPolygon.current);
    }

    try {
      displayPolygon.current = L.polygon(validCoords, {
        color: '#FFD700',
        weight: 3,
        fillColor: '#FFD700',
        fillOpacity: 0.2,
      }).addTo(map.current);

      const bounds = displayPolygon.current.getBounds();
      
      if (bounds.isValid()) {
        map.current.fitBounds(bounds, { padding: [50, 50] });
      } else {
        // Fallback to center if bounds invalid
        console.warn('Bounds invalid, using center point');
        if (parcelData?.latitude && parcelData?.longitude) {
          map.current.setView([parcelData.latitude, parcelData.longitude], 19);
        }
      }
    } catch (error) {
      console.error('Error creating parcel layer:', error);
      // Fallback to center point
      if (parcelData?.latitude && parcelData?.longitude) {
        map.current.setView([parcelData.latitude, parcelData.longitude], 19);
      }
    }
  };

  const createDraggableVertices = (coords: [number, number][]) => {
    if (!map.current) return;

    vertexMarkers.current.forEach(marker => map.current?.removeLayer(marker));
    vertexMarkers.current = [];

    coords.forEach((coord, index) => {
      const marker = L.marker(coord, {
        icon: vertexIcon(index),
        draggable: true,
        autoPan: true
      });

      marker.addTo(map.current!);
      vertexMarkers.current.push(marker);

      marker.on('dragstart', (e: any) => {
        setIsDraggingVertex(true);
        setDraggedVertexIndex(index);
        setOriginalVertexPosition(e.target.getLatLng());
        toast.info('Dragging vertex... Hold Shift to snap', { duration: 2000 });
      });

      marker.on('drag', (e: any) => {
        let newLatLng = e.target.getLatLng();
        
        if (isShiftPressed) {
          const snappedLat = snapToGrid(newLatLng.lat, 0.0001);
          const snappedLng = snapToGrid(newLatLng.lng, 0.0001);
          newLatLng = L.latLng(snappedLat, snappedLng);
          e.target.setLatLng(newLatLng);
        }
        
        setBoundaryCoords(prevCoords => {
          const newCoords = [...prevCoords];
          newCoords[index] = [newLatLng.lat, newLatLng.lng];
          
          if (editablePolygon.current) {
            editablePolygon.current.setLatLngs(newCoords);
          }
          
          return newCoords;
        });
      });

      marker.on('dragend', () => {
        setIsDraggingVertex(false);
        setDraggedVertexIndex(null);
        toast.success('Vertex updated');
        
        const geojson = {
          type: 'Polygon',
          coordinates: [ensureClosedPolygon(boundaryCoords.map(c => [c[1], c[0]]))]
        };
        calculateAndDrawSetbacks(geojson);
      });
    });
  };

  const createEdgeMarkers = (coords: [number, number][]) => {
    if (!map.current) return;

    edgeMarkers.current.forEach(marker => map.current?.removeLayer(marker));
    edgeMarkers.current = [];

    coords.forEach((coord, index) => {
      const nextIndex = (index + 1) % coords.length;
      const nextCoord = coords[nextIndex];
      
      const midLat = (coord[0] + nextCoord[0]) / 2;
      const midLng = (coord[1] + nextCoord[1]) / 2;
      
      const existingLabel = edgeLabels.find(el => el.edgeIndex === index);
      const side = existingLabel?.side || null;
      
      const marker = L.marker([midLat, midLng], {
        icon: getEdgeIcon(side),
        draggable: false
      });

      marker.addTo(map.current!);
      edgeMarkers.current.push(marker);

      marker.on('click', () => {
        cycleSideLabel(index);
      });
    });
  };

  const cycleSideLabel = (edgeIndex: number) => {
    const sides: Array<'front' | 'rear' | 'left' | 'right'> = ['front', 'rear', 'left', 'right'];
    const existingLabel = edgeLabels.find(el => el.edgeIndex === edgeIndex);
    
    if (!existingLabel) {
      setEdgeLabels(prev => [...prev, { edgeIndex, side: 'front' }]);
    } else {
      const currentIndex = sides.indexOf(existingLabel.side);
      const nextIndex = (currentIndex + 1) % sides.length;
      const newSide = sides[nextIndex];
      
      setEdgeLabels(prev => prev.map(el =>
        el.edgeIndex === edgeIndex
          ? { ...el, side: newSide }
          : el
      ));
    }
  };

  useEffect(() => {
    if (isLabelingEdges && boundaryCoords.length > 0) {
      createEdgeMarkers(boundaryCoords);
    } else {
      edgeMarkers.current.forEach(marker => map.current?.removeLayer(marker));
      edgeMarkers.current = [];
    }
  }, [isLabelingEdges, boundaryCoords, edgeLabels]);

  const toggleBoundaryEdit = () => {
    if (!map.current || !displayPolygon.current) return;

    if (isEditingBoundary) {
      vertexMarkers.current.forEach(marker => map.current?.removeLayer(marker));
      vertexMarkers.current = [];
      
      if (editablePolygon.current) {
        map.current.removeLayer(editablePolygon.current);
        editablePolygon.current = null;
      }
      
      try {
        if (map.current.dragging) {
          map.current.dragging.enable();
        }
      } catch (e) {
        console.log('Could not enable dragging');
      }
      
      if (!map.current.hasLayer(displayPolygon.current)) {
        displayPolygon.current.addTo(map.current);
      }
      
      setIsEditingBoundary(false);
    } else {
      if (displayPolygon.current) {
        map.current.removeLayer(displayPolygon.current);
      }
      
      try {
        if (map.current.dragging) {
          map.current.dragging.disable();
        }
      } catch (e) {
        console.log('Could not disable dragging');
      }
      
      editablePolygon.current = L.polygon(boundaryCoords, {
        color: '#FFD700',
        weight: 3,
        fillColor: '#FFD700',
        fillOpacity: 0.2,
      }).addTo(map.current);
      
      createDraggableVertices(boundaryCoords);
      setIsEditingBoundary(true);
    }
  };

  const saveBoundary = async () => {
    console.log('üîç Saving boundary and edge labels');
    
    if (!parcelData?.id) {
      alert('‚ùå No parcel ID found - cannot save boundary');
      return;
    }
    
    try {
      const closedCoords = ensureClosedPolygon(boundaryCoords.map(c => [c[1], c[0]]));

      const response = await fetch('/api/parcels/update-boundary', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          parcelId: parcelData.id,
          coordinates: closedCoords,
          edgeLabels: edgeLabels
        })
      });

      const result = await response.json();

      if (response.ok) {
        alert('‚úÖ Property boundary and edge labels saved successfully!');
        
        vertexMarkers.current.forEach(marker => map.current?.removeLayer(marker));
        vertexMarkers.current = [];
        
        if (editablePolygon.current && map.current) {
          map.current.removeLayer(editablePolygon.current);
          editablePolygon.current = null;
        }
        
        try {
          if (map.current && map.current.dragging) {
            map.current.dragging.enable();
          }
        } catch (e) {
          console.log('Could not enable dragging');
        }
        
        addParcelLayer(boundaryCoords);
        const geojson = {
          type: 'Polygon',
          coordinates: [ensureClosedPolygon(boundaryCoords.map(c => [c[1], c[0]]))]
        };
        calculateAndDrawSetbacks(geojson);        
        
        setIsEditingBoundary(false);
      } else {
        alert('‚ùå Failed to save boundary: ' + (result.error || 'Unknown error'));
      }
    } catch (error) {
      console.error('‚ùå Error saving boundary:', error);
      alert('‚ùå Error saving boundary: ' + error);
    }
  };

  const addBuildingLayer = (footprint: any) => {
    if (!map.current) return;

    if (buildingLayer.current) {
      map.current.removeLayer(buildingLayer.current);
    }

    buildingLayer.current = L.geoJSON(footprint, {
      style: {
        color: '#FF6B6B',
        weight: 2,
        fillColor: '#FF6B6B',
        fillOpacity: 0.6,
      },
    });

    buildingLayer.current.addTo(map.current);
  };

  const calculateAndDrawSetbacks = useCallback((geometry: any) => {
    if (!map.current || !setbackLayer.current) return;

    setbackLayer.current.clearLayers();

    if (!showSetbacks) return;

    try {
      const polygon = turf.polygon(geometry.coordinates);
      
      if (edgeLabels.length === boundaryCoords.length) {
        
        boundaryCoords.forEach((coord, index) => {
          const nextIndex = (index + 1) % boundaryCoords.length;
          const nextCoord = boundaryCoords[nextIndex];
          
          const edgeLabel = edgeLabels.find(el => el.edgeIndex === index);
          if (!edgeLabel) return;
          
          const setbackFeet = setbacks[edgeLabel.side];
          const setbackMeters = setbackFeet * 0.3048;
          
          const edgeLine = turf.lineString([
            [coord[1], coord[0]],
            [nextCoord[1], nextCoord[0]]
          ]);
          
          try {
            const offsetLine = turf.lineOffset(edgeLine, -setbackMeters / 1000, { units: 'kilometers' });
            
            const colors = {
              front: '#ef4444',
              rear: '#3b82f6',
              left: '#10b981',
              right: '#f59e0b'
            };
            
            L.geoJSON(offsetLine, {
              style: {
                color: colors[edgeLabel.side],
                weight: 2,
                dashArray: '5, 5',
                opacity: 0.8
              }
            }).addTo(setbackLayer.current!);
            
          } catch (error) {
            console.error('Error calculating offset for edge:', index, error);
          }
        });
        
        const minSetback = Math.min(setbacks.front, setbacks.rear, setbacks.left, setbacks.right);
        const minSetbackMeters = minSetback * 0.3048;
        const buffered = turf.buffer(polygon, -minSetbackMeters / 1000, { units: 'kilometers' });
        
        if (buffered) {
          L.geoJSON(buffered, {
            style: {
              color: 'transparent',
              fillColor: '#90EE90',
              fillOpacity: 0.3
            }
          }).addTo(setbackLayer.current!);
          
          const buildableAreaSqMeters = turf.area(buffered);
          const buildableAreaSqFt = buildableAreaSqMeters * 10.764;
          setBuildableArea(Math.round(buildableAreaSqFt));
        }
      } else {
        const avgSetbackFeet = (setbacks.front + setbacks.rear + setbacks.left + setbacks.right) / 4;
        const avgSetbackMeters = avgSetbackFeet * 0.3048;
        
        const buffered = turf.buffer(polygon, -avgSetbackMeters / 1000, { units: 'kilometers' });
        
        if (buffered) {
          L.geoJSON(buffered, {
            style: {
              color: '#FF0000',
              weight: 2,
              fillColor: '#90EE90',
              fillOpacity: 0.3,
              dashArray: '10, 10'
            }
          }).addTo(setbackLayer.current!);

          const buildableAreaSqMeters = turf.area(buffered);
          const buildableAreaSqFt = buildableAreaSqMeters * 10.764;
          setBuildableArea(Math.round(buildableAreaSqFt));
        }
      }

    } catch (error) {
      console.error('‚ùå Error calculating setbacks:', error);
    }
  }, [setbacks, showSetbacks, boundaryCoords, edgeLabels]);

  useEffect(() => {
    if (!boundaryCoords || boundaryCoords.length === 0) return;

    const geojson = {
      type: 'Polygon',
      coordinates: [ensureClosedPolygon(boundaryCoords.map(c => [c[1], c[0]]))]
    };
    calculateAndDrawSetbacks(geojson);
  }, [setbacks, calculateAndDrawSetbacks, boundaryCoords, edgeLabels]);

  const handleSetbackChange = (side: keyof typeof setbacks, value: string) => {
    const numValue = parseInt(value) || 0;
    setSetbacks(prev => ({
      ...prev,
      [side]: numValue
    }));
  };

  const saveSetbacks = async () => {
    try {
      const response = await fetch('/api/projects/update-setbacks', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          projectId,
          setbacks
        })
      });

      if (response.ok) {
        alert('‚úÖ Setbacks saved successfully!');
        setIsEditingSetbacks(false);
      } else {
        alert('‚ùå Failed to save setbacks');
      }
    } catch (error) {
      console.error('Error saving setbacks:', error);
      alert('‚ùå Error saving setbacks');
    }
  };

  const toggleDrawing = () => {
    if (!map.current || !drawControl.current || !drawLayer.current) return;

    if (isDrawing) {
      map.current.removeControl(drawControl.current);
      map.current.off(L.Draw.Event.CREATED);
      setIsDrawing(false);
    } else {
      map.current.addControl(drawControl.current);
      setIsDrawing(true);

      map.current.on(L.Draw.Event.CREATED, (e: any) => {
        const layer = e.layer;
        const geoJSON = layer.toGeoJSON();
        
        try {
          const polygon = turf.polygon(geoJSON.geometry.coordinates);
          const areaMeters = turf.area(polygon);
          const areaSqFt = areaMeters * 10.764;
          
          const perimeterMeters = turf.length(turf.polygonToLine(polygon), { units: 'meters' });
          const perimeterFeet = perimeterMeters * 3.28084;
          
          const shapeCount = drawnShapes.length + 1;
          const defaultName = `Shape ${shapeCount}`;
          
          // Get coordinates for dimension labels
          const coords = layer.getLatLngs()[0].map((ll: any) => [ll.lat, ll.lng] as [number, number]);
          const dimensionLabels = createDimensionLabels(coords);
          
          // Add dimension labels to map
          dimensionLabels.forEach(label => drawLayer.current?.addLayer(label));
          
          drawLayer.current?.addLayer(layer);
          
          const shapeId = `shape-${Date.now()}`;
          setDrawnShapes(prev => [...prev, {
            id: shapeId,
            name: defaultName,
            area: Math.round(areaSqFt),
            perimeter: Math.round(perimeterFeet),
            layer: layer,
            dimensionLabels: dimensionLabels
          }]);
          
          checkViolations(geoJSON);
          
        } catch (error) {
          console.error('Error calculating shape measurements:', error);
          drawLayer.current?.addLayer(layer);
        }
      });
    }
  };

  const toggleShapeEditing = () => {
    if (!map.current || !editControl.current || !drawLayer.current) return;

    if (isEditingShapes) {
      try {
        map.current.removeControl(editControl.current);
        map.current.off(L.Draw.Event.EDITED);
      } catch (error) {
        console.error('Error disabling shape editing:', error);
      }
      setIsEditingShapes(false);
    } else {
      try {
        map.current.addControl(editControl.current);
      } catch (error) {
        console.error('Error enabling shape editing:', error);
        alert('Unable to enable shape editing mode. Please refresh the page.');
        return;
      }
      
      setIsEditingShapes(true);

      map.current.on(L.Draw.Event.EDITED, (e: any) => {
        try {
          const layers = e.layers;
          layers.eachLayer((layer: any) => {
            const shape = drawnShapes.find(s => s.layer === layer);
            if (shape && drawLayer.current) {
              try {
                const geoJSON = layer.toGeoJSON();
                const polygon = turf.polygon(geoJSON.geometry.coordinates);
                const areaMeters = turf.area(polygon);
                const areaSqFt = areaMeters * 10.764;
                
                const perimeterMeters = turf.length(turf.polygonToLine(polygon), { units: 'meters' });
                const perimeterFeet = perimeterMeters * 3.28084;
                
                // Remove old dimension labels
                shape.dimensionLabels.forEach((dimLabel: any) => {
                  try {
                    drawLayer.current?.removeLayer(dimLabel);
                  } catch (e) {}
                });
                
                // Get updated coordinates
                const coords = layer.getLatLngs()[0].map((ll: any) => [ll.lat, ll.lng] as [number, number]);
                const newDimensionLabels = createDimensionLabels(coords);
                
                // Add new dimension labels
                newDimensionLabels.forEach(label => drawLayer.current?.addLayer(label));
                
                setDrawnShapes(prev => prev.map(s =>
                  s.id === shape.id
                    ? {
                        ...s,
                        area: Math.round(areaSqFt),
                        perimeter: Math.round(perimeterFeet),
                        dimensionLabels: newDimensionLabels
                      }
                    : s
                ));
                
                // Check violations after moving/editing
                checkViolations(geoJSON);
                
              } catch (error) {
                console.error('Error updating shape measurements:', error);
              }
            }
          });
        } catch (error) {
          console.error('Error processing edited layers:', error);
        }
      });
    }
  };

  const updateShapeName = (shapeId: string, newName: string) => {
    setDrawnShapes(prev => prev.map(shape =>
      shape.id === shapeId ? { ...shape, name: newName } : shape
    ));
    setEditingShapeId(null);
  };

  const deleteShape = (shapeId: string) => {
    const shape = drawnShapes.find(s => s.id === shapeId);
    if (shape && drawLayer.current) {
      drawLayer.current.removeLayer(shape.layer);
      shape.dimensionLabels.forEach((dimLabel: any) => {
        try {
          drawLayer.current?.removeLayer(dimLabel);
        } catch (e) {}
      });
      setDrawnShapes(prev => prev.filter(s => s.id !== shapeId));
    }
  };

  const clearDrawings = () => {
    drawLayer.current?.clearLayers();
    setViolations([]);
    setDrawnShapes([]);
  };

  const toggleFullscreen = () => {
    setIsFullscreen(!isFullscreen);
  };

  return (
    <div className="space-y-4">
      {/* Header with Title and Help Button */}
      <div className="flex items-center justify-between">
        <div>
          <h2 className="text-2xl font-bold">Property Visualization</h2>
          <p className="text-sm text-gray-500">Interactive map showing property boundaries</p>
        </div>
        <Dialog>
          <DialogTrigger asChild>
            <Button variant="outline">
              <HelpCircle className="h-4 w-4 mr-2" />
              Help Guide
            </Button>
          </DialogTrigger>
          <DialogContent className="max-w-2xl max-h-[80vh] overflow-y-auto z-[99999]">
            <DialogHeader>
              <DialogTitle>Property Visualization Guide</DialogTitle>
              <DialogDescription>
                Learn how to use all the map features
              </DialogDescription>
            </DialogHeader>
            <div className="space-y-4">
              <div>
                <h4 className="font-semibold text-sm mb-2">üó∫Ô∏è Viewing Options</h4>
                <ul className="text-sm space-y-1 ml-4">
                  <li>‚Ä¢ <strong>Satellite/Street</strong> - Toggle between map views</li>
                  <li>‚Ä¢ <strong>Parcel</strong> - Show/hide property boundary (yellow)</li>
                  <li>‚Ä¢ <strong>Setbacks</strong> - Show/hide buildable area (green)</li>
                </ul>
              </div>

              <div>
                <h4 className="font-semibold text-sm mb-2">‚úèÔ∏è Editing Property Boundary</h4>
                <ul className="text-sm space-y-1 ml-4">
                  <li>1. Click <strong>"Edit Boundary"</strong></li>
                  <li>2. Drag the blue dots to adjust corners</li>
                  <li>3. Click <strong>"Save Boundary"</strong> when done</li>
                </ul>
              </div>

              <div>
                <h4 className="font-semibold text-sm mb-2">üè∑Ô∏è Labeling Property Sides</h4>
                <ul className="text-sm space-y-1 ml-4">
                  <li>1. Click <strong>"Label Edges"</strong></li>
                  <li>2. Click markers on each side to cycle: Front ‚Üí Rear ‚Üí Left ‚Üí Right</li>
                  <li>3. Label all sides for accurate setback calculations</li>
                  <li>4. Click <strong>"Done Labeling"</strong></li>
                </ul>
              </div>

              <div>
                <h4 className="font-semibold text-sm mb-2">üìê Drawing Building Shapes</h4>
                <ul className="text-sm space-y-1 ml-4">
                  <li>1. Click <strong>"Draw"</strong></li>
                  <li>2. Use toolbar buttons:
                    <ul className="ml-4 mt-1">
                      <li>- <strong>Draw a polygon</strong> - Click points, double-click to finish</li>
                      <li>- <strong>Draw a rectangle</strong> - Click and drag</li>
                    </ul>
                  </li>
                  <li>3. <strong>Blue dimension labels</strong> show the length of each side in feet</li>
                  <li>4. Name each shape in the "Drawn Shapes" panel (click the pencil icon)</li>
                </ul>
              </div>

              <div>
                <h4 className="font-semibold text-sm mb-2">‚ÜîÔ∏è Moving & Editing Shapes - IMPORTANT!</h4>
                <ul className="text-sm space-y-1 ml-4 bg-yellow-50 p-3 rounded border border-yellow-200">
                  <li>1. After drawing, click <strong>"Move Shapes"</strong> button</li>
                  <li>2. Click <strong>"Edit layers"</strong> (pencil icon) in the Leaflet toolbar</li>
                  <li>3. Click a shape to select it (turns purple with dots)</li>
                  <li>4. <strong className="text-red-600">To move the ENTIRE shape:</strong>
                    <ul className="ml-4 mt-1">
                      <li>- Click and hold in the CENTER/MIDDLE of the shape</li>
                      <li>- DO NOT click on corners or edges</li>
                      <li>- Drag to new location</li>
                      <li>- Dimension labels will move with the shape</li>
                    </ul>
                  </li>
                  <li>5. <strong>To resize/reshape:</strong> Drag the corner dots - dimensions update automatically</li>
                  <li>6. Click <strong>"Save"</strong> (floppy disk icon) in toolbar when done</li>
                  <li>7. Click <strong>"Done Moving"</strong> button</li>
                </ul>
              </div>

              <div>
                <h4 className="font-semibold text-sm mb-2">‚ö†Ô∏è Setback Violations</h4>
                <ul className="text-sm space-y-1 ml-4">
                  <li>‚Ä¢ Shapes are automatically checked against setback rules</li>
                  <li>‚Ä¢ ‚úÖ Green checkmark = Complies with setbacks</li>
                  <li>‚Ä¢ ‚ùå Red X = Violates setback requirements</li>
                  <li>‚Ä¢ Check happens when drawing AND when moving shapes</li>
                </ul>
              </div>

              <div>
                <h4 className="font-semibold text-sm mb-2">üìä Measurements & Naming</h4>
                <ul className="text-sm space-y-1 ml-4">
                  <li>‚Ä¢ All shapes show area (sq ft) and perimeter (ft) in the panel</li>
                  <li>‚Ä¢ <strong>Blue dimension labels</strong> show the length of each side in feet</li>
                  <li>‚Ä¢ Click the pencil icon next to a shape name to edit it</li>
                  <li>‚Ä¢ Give shapes meaningful names like "Main House", "ADU", "Garage"</li>
                  <li>‚Ä¢ Total area of all shapes shown at bottom</li>
                  <li>‚Ä¢ Measurements update automatically when editing</li>
                </ul>
              </div>

              <div className="pt-4 border-t">
                <p className="text-xs text-gray-600 bg-blue-50 p-3 rounded">
                  <strong>üí° Pro Tip:</strong> When moving shapes, click and drag from the CENTER of the shape (not edges or corners). This moves the whole shape along with all its dimension labels!
                </p>
              </div>
            </div>
          </DialogContent>
        </Dialog>
      </div>

      {/* Map Container */}
      <Card className={`relative ${isFullscreen ? 'fixed inset-0 z-50 rounded-none' : ''}`}>
        <div className="relative w-full h-[600px]">
          <div ref={mapContainer} className="absolute inset-0 rounded-lg" />
          
          {/* Top Center - Mode Toolbar */}
          <MapToolbar
            mode={mode}
            onModeChange={setMode}
            onZoomIn={() => map.current?.zoomIn()}
            onZoomOut={() => map.current?.zoomOut()}
            onUndo={() => console.log('Undo - coming soon')}
            onRedo={() => console.log('Redo - coming soon')}
            canUndo={false}
            canRedo={false}
          />
          
          {isLoading && (
            <div className="absolute inset-0 flex items-center justify-center bg-background/80 backdrop-blur-sm">
              <Loader2 className="h-8 w-8 animate-spin text-primary" />
            </div>
          )}

          {/* Bottom Left - Layer Controls */}
          <div className="absolute bottom-4 left-4 flex gap-2 z-[1000]">
            <Button
              size="sm"
              variant={activeLayer === 'satellite' ? 'selected' : 'outline'}
              onClick={() => setActiveLayer('satellite')}
              className="shadow-sm"
            >
              <MapPin className="h-4 w-4 mr-2" />
              Satellite
            </Button>
            <Button
              size="sm"
              variant={activeLayer === 'street' ? 'selected' : 'outline'}
              onClick={() => setActiveLayer('street')}
              className="shadow-sm"
            >
              <Map className="h-4 w-4 mr-2" />
              Street
            </Button>
          </div>

          {/* Bottom Right - Map Controls (Edit mode only) */}
          {mode === 'edit' && (
            <div className="absolute bottom-4 right-4 flex flex-col gap-2 z-[1000]">
            <Button
              size="sm"
              variant={showParcel ? 'selected' : 'outline'}
              onClick={() => setShowParcel(!showParcel)}
              className="shadow-sm"
            >
              <Grid3x3 className="h-4 w-4 mr-2" />
              Parcel
            </Button>
            <Button
              size="sm"
              variant={showSetbacks ? 'selected' : 'outline'}
              onClick={() => setShowSetbacks(!showSetbacks)}
              className="shadow-sm"
            >
              <Building2 className="h-4 w-4 mr-2" />
              Setbacks
            </Button>
            <Button
              size="sm"
              variant={isEditingBoundary ? 'selected' : 'outline'}
              onClick={toggleBoundaryEdit}
              className="shadow-sm"
            >
              <Edit className="h-4 w-4 mr-2" />
              Edit Boundary
            </Button>
            {isEditingBoundary && (
              <Button
                size="sm"
                variant="default"
                onClick={saveBoundary}
                className="shadow-lg bg-green-600 hover:bg-green-700"
              >
                <Check className="h-4 w-4 mr-2" />
                Save Boundary
              </Button>
            )}
            <Button
              size="sm"
              variant={isLabelingEdges ? 'selected' : 'outline'}
              onClick={() => setIsLabelingEdges(!isLabelingEdges)}
              className="shadow-sm"
            >
              <Tag className="h-4 w-4 mr-2" />
              {isLabelingEdges ? 'Done Labeling' : 'Label Edges'}
            </Button>
            <Button
              size="sm"
              variant={isDrawing ? 'selected' : 'outline'}
              onClick={toggleDrawing}
              className="shadow-sm"
            >
              <Edit className="h-4 w-4 mr-2" />
              Draw
            </Button>
            {drawnShapes.length > 0 && (
              <Button
                size="sm"
                variant={isEditingShapes ? 'selected' : 'outline'}
                onClick={toggleShapeEditing}
                className="shadow-sm"
              >
                <Move className="h-4 w-4 mr-2" />
                {isEditingShapes ? 'Done Moving' : 'Move Shapes'}
              </Button>
            )}
            {isDrawing && (
              <Button
                size="sm"
                variant="destructive"
                onClick={clearDrawings}
                className="shadow-lg"
              >
                <X className="h-4 w-4 mr-2" />
                Clear All
              </Button>
            )}
            <Button
              size="sm"
              variant={isFullscreen ? 'selected' : 'outline'}
              onClick={toggleFullscreen}
              className="shadow-sm"
            >
              {isFullscreen ? (
                <Minimize2 className="h-4 w-4" />
              ) : (
                <Maximize2 className="h-4 w-4" />
              )}
            </Button>
          </div>
          )}



          {/* Violations Warning */}
          {violations.length > 0 && (
            <Card className="absolute top-24 right-4 p-3 shadow-lg z-[1000] max-w-xs bg-white">
              <div className="flex items-start gap-2">
                <AlertTriangle className="h-4 w-4 text-orange-500 mt-0.5" />
                <div className="space-y-1">
                  {violations.map((violation, idx) => (
                    <p key={idx} className="text-xs">{violation}</p>
                  ))}
                </div>
              </div>
            </Card>
          )}
        </div>
      </Card>

      {/* Property Info - Below Map */}
      {parcelData && (
        <div className="grid grid-cols-2 md:grid-cols-4 gap-4 p-4 bg-gray-50 rounded-lg border">
          {parcelData.apn && (
            <div>
              <div className="text-xs text-gray-500 mb-1">APN</div>
              <div className="text-sm font-semibold">{parcelData.apn}</div>
            </div>
          )}
          {parcelData.lotSizeSqFt && (
            <div>
              <div className="text-xs text-gray-500 mb-1">Lot Size</div>
              <div className="text-sm font-semibold">{parcelData.lotSizeSqFt.toLocaleString()} sq ft</div>
            </div>
          )}
          {parcelData.zoning && (
            <div>
              <div className="text-xs text-gray-500 mb-1">Zoning</div>
              <div className="text-sm font-semibold">{parcelData.zoning}</div>
            </div>
          )}
          {buildableArea !== null && (
            <div>
              <div className="text-xs text-gray-500 mb-1">Buildable Area</div>
              <div className="text-sm font-semibold text-green-600">{buildableArea.toLocaleString()} sq ft</div>
            </div>
          )}
        </div>
      )}

      {/* Setbacks and Drawn Shapes */}
      <div className="grid grid-cols-1 lg:grid-cols-3 gap-4">
        {/* Setbacks Panel */}
        <Card className="p-4 lg:col-span-2">
          <div className="flex items-center justify-between mb-4">
            <div className="flex items-center gap-2">
              <h3 className="font-semibold">Setback Requirements</h3>
              {isLabelingEdges && (
                <span className="text-xs bg-blue-100 text-blue-800 px-2 py-1 rounded">
                  Labeled: {edgeLabels.length} of {boundaryCoords.length}
                </span>
              )}
            </div>
            <Button
              size="sm"
              variant={isEditingSetbacks ? 'selected' : 'secondary'}
              onClick={() => setIsEditingSetbacks(!isEditingSetbacks)}
            >
              {isEditingSetbacks ? 'Cancel' : 'Edit Setbacks'}
            </Button>
          </div>

          {isLabelingEdges && (
            <div className="mb-4 p-3 bg-blue-50 border border-blue-200 rounded">
              <p className="text-sm font-semibold text-blue-900 mb-2">Click edge markers on the map to label sides:</p>
              <div className="flex flex-wrap gap-3">
                <div className="flex items-center gap-1">
                  <div className="w-4 h-4 rounded" style={{backgroundColor: '#ef4444'}}></div>
                  <span className="text-sm">Front (Street)</span>
                </div>
                <div className="flex items-center gap-1">
                  <div className="w-4 h-4 rounded" style={{backgroundColor: '#3b82f6'}}></div>
                  <span className="text-sm">Rear (Back)</span>
                </div>
                <div className="flex items-center gap-1">
                  <div className="w-4 h-4 rounded" style={{backgroundColor: '#10b981'}}></div>
                  <span className="text-sm">Left Side</span>
                </div>
                <div className="flex items-center gap-1">
                  <div className="w-4 h-4 rounded" style={{backgroundColor: '#f59e0b'}}></div>
                  <span className="text-sm">Right Side</span>
                </div>
              </div>
            </div>
          )}

          <div className="grid grid-cols-4 gap-4">
            <div>
              <Label htmlFor="front" className="text-sm font-semibold flex items-center gap-2 mb-2">
                <div className="w-4 h-4 rounded" style={{backgroundColor: '#ef4444'}}></div>
                Front Street
              </Label>
              <div className="flex items-center gap-2">
                <Input
                  id="front"
                  type="number"
                  value={setbacks.front}
                  onChange={(e) => handleSetbackChange('front', e.target.value)}
                  disabled={!isEditingSetbacks}
                  className="h-10"
                />
                <span className="text-sm text-gray-500">ft</span>
              </div>
            </div>

            <div>
              <Label htmlFor="rear" className="text-sm font-semibold flex items-center gap-2 mb-2">
                <div className="w-4 h-4 rounded" style={{backgroundColor: '#3b82f6'}}></div>
                Rear (Back)
              </Label>
              <div className="flex items-center gap-2">
                <Input
                  id="rear"
                  type="number"
                  value={setbacks.rear}
                  onChange={(e) => handleSetbackChange('rear', e.target.value)}
                  disabled={!isEditingSetbacks}
                  className="h-10"
                />
                <span className="text-sm text-gray-500">ft</span>
              </div>
            </div>

            <div>
              <Label htmlFor="left" className="text-sm font-semibold flex items-center gap-2 mb-2">
                <div className="w-4 h-4 rounded" style={{backgroundColor: '#10b981'}}></div>
                Side Left
              </Label>
              <div className="flex items-center gap-2">
                <Input
                  id="left"
                  type="number"
                  value={setbacks.left}
                  onChange={(e) => handleSetbackChange('left', e.target.value)}
                  disabled={!isEditingSetbacks}
                  className="h-10"
                />
                <span className="text-sm text-gray-500">ft</span>
              </div>
            </div>

            <div>
              <Label htmlFor="right" className="text-sm font-semibold flex items-center gap-2 mb-2">
                <div className="w-4 h-4 rounded" style={{backgroundColor: '#f59e0b'}}></div>
                Side Right
              </Label>
              <div className="flex items-center gap-2">
                <Input
                  id="right"
                  type="number"
                  value={setbacks.right}
                  onChange={(e) => handleSetbackChange('right', e.target.value)}
                  disabled={!isEditingSetbacks}
                  className="h-10"
                />
                <span className="text-sm text-gray-500">ft</span>
              </div>
            </div>
          </div>

          {isEditingSetbacks && (
            <div className="mt-4 flex justify-end">
              <Button onClick={saveSetbacks}>
                <Save className="h-4 w-4 mr-2" />
                Save Setbacks
              </Button>
            </div>
          )}
        </Card>

        {/* Drawn Shapes Panel */}
        <Card className="p-4">
          <div className="flex items-center justify-between mb-3">
            <h3 className="font-semibold text-sm flex items-center gap-2">
              <Building2 className="h-4 w-4" />
              Drawn Shapes ({drawnShapes.length})
            </h3>
          </div>

          {drawnShapes.length === 0 ? (
            <div className="text-center py-4">
              <p className="text-sm text-gray-500 mb-2">
                No shapes drawn yet.
              </p>
              <p className="text-xs text-gray-400">
                Click "Draw" to add building footprints
              </p>
            </div>
          ) : (
            <>
              <p className="text-xs text-gray-500 mb-3 p-2 bg-blue-50 rounded">
                üí° Click the pencil icon to rename shapes (e.g., "Main House", "ADU", "Garage")
              </p>
              <div className="space-y-3 max-h-80 overflow-y-auto mb-3">
                {drawnShapes.map((shape, idx) => (
                  <div key={shape.id} className="p-3 bg-blue-50 rounded border border-blue-200">
                    <div className="flex justify-between items-start mb-2">
                      {editingShapeId === shape.id ? (
                        <Input
                          autoFocus
                          value={shape.name}
                          onChange={(e) => setDrawnShapes(prev => prev.map(s =>
                            s.id === shape.id ? { ...s, name: e.target.value } : s
                          ))}
                          onBlur={() => setEditingShapeId(null)}
                          onKeyDown={(e) => {
                            if (e.key === 'Enter') {
                              setEditingShapeId(null);
                            }
                          }}
                          className="h-8 text-sm font-semibold"
                          placeholder="e.g., Main House, ADU, Garage"
                        />
                      ) : (
                        <div className="flex items-center gap-2 flex-1">
                          <span className="font-semibold text-sm text-blue-900">{shape.name}</span>
                          <Button
                            size="sm"
                            variant="ghost"
                            onClick={() => setEditingShapeId(shape.id)}
                            className="h-6 w-6 p-0"
                            title="Click to rename this shape"
                          >
                            <Pencil className="h-3 w-3 text-gray-500" />
                          </Button>
                        </div>
                      )}
                      <Button
                        size="sm"
                        variant="ghost"
                        onClick={() => deleteShape(shape.id)}
                        className="h-6 w-6 p-0"
                        title="Delete this shape"
                      >
                        <Trash2 className="h-4 w-4 text-red-500" />
                      </Button>
                    </div>
                    <div className="text-xs text-gray-700">{shape.area.toLocaleString()} sq ft</div>
                    <div className="text-xs text-gray-600">{shape.perimeter.toLocaleString()} ft perimeter</div>
                  </div>
                ))}
              </div>

              <div className="pt-3 border-t">
                <div className="flex justify-between items-center">
                  <span className="font-semibold text-sm">Total Area</span>
                  <span className="text-lg font-bold text-blue-600">
                    {drawnShapes.reduce((sum, s) => sum + s.area, 0).toLocaleString()} sq ft
                  </span>
                </div>
              </div>
            </>
          )}
        </Card>
      </div>
    </div>

  );
}
